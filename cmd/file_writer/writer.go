package file_writer

import (
	"io"
	"strings"

	"github.com/pkg/errors"
)

const (
	EntriesHeader = "######## AUTOGENERATED BY TRAEFIK_HOSTS_GENERATOR ################"
	EntriesFooter = "######## AUTOGENERATED BY TRAEFIK_HOSTS_GENERATOR END ############"

	HostsReadSize = 100000
)

type HostsAdapter interface {
	io.ReadWriter
	Append([]byte) error
}

type Writer struct {
	postfix       string
	lineEndings   string
	hostsAdapter  HostsAdapter
	entriesHeader string
	entriesFooter string
}

func NewWriter(hostsAdapter HostsAdapter, lineEndings, postfix string) *Writer {
	return &Writer{
		postfix:       postfix,
		lineEndings:   lineEndings,
		hostsAdapter:  hostsAdapter,
		entriesHeader: lineEndings + EntriesHeader + " " + postfix,
		entriesFooter: EntriesFooter + " " + postfix + lineEndings,
	}
}

func (w *Writer) WriteToHosts(newHosts string) error {
	currentContent, err := w.getCurrentHostsContent()
	if err != nil {
		return errors.Wrap(err, "reading current file content failed")
	}

	headerPresent := w.isHeaderPresent(currentContent)
	footerPresent := w.isFooterPresent(currentContent)

	if headerPresent && footerPresent {
		return w.replaceContent(newHosts)
	}

	if !headerPresent && !footerPresent {
		return w.insertContent(newHosts)
	}

	return errors.New("hosts content malformed, traefik section is partially present")
}

func (w *Writer) Clear() error {
	headerStart, footerStart, err := w.getCurrentPositions()
	if err != nil {
		return err
	}
	currentContent, err := w.getCurrentHostsContent()
	if err != nil {
		return err
	}

	fullCurrentContext := ""
	newContent := ""
	if headerStart == footerStart && footerStart == -1 {
		// there is no content created by current generator
		return nil
	}

	fullCurrentContext = currentContent[headerStart : footerStart+len(w.entriesFooter)]
	newContent = strings.ReplaceAll(currentContent, fullCurrentContext, "")

	_, err = w.hostsAdapter.Write([]byte(newContent))

	if err != nil {
		return errors.Wrap(err, "cannot write new hosts content")
	}
	return nil
}

func (w *Writer) getCurrentHostsContent() (string, error) {
	content := make([]byte, HostsReadSize)
	_, err := w.hostsAdapter.Read(content)
	if err != nil {
		return "", nil
	}

	return strings.Trim(string(content), string(rune(0))), nil
}

func (w *Writer) insertContent(newHosts string) error {

	newHosts = strings.Join([]string{w.entriesHeader, newHosts, w.entriesFooter}, w.lineEndings)

	return w.hostsAdapter.Append([]byte(newHosts))
}

func (w *Writer) getCurrentPositions() (headerStart, footerStart int, err error) {
	var currentContent string
	currentContent, err = w.getCurrentHostsContent()
	if err != nil {
		return
	}
	headerStart = strings.Index(currentContent, w.entriesHeader)
	footerStart = strings.Index(currentContent, w.entriesFooter)
	return
}

func (w *Writer) getCurrentGeneratedHosts() (string, error) {
	headerStart, footerStart, err := w.getCurrentPositions()
	if err != nil {
		return "", err
	}
	currentContent, err := w.getCurrentHostsContent()
	if err != nil {
		return "", err
	}
	return currentContent[headerStart+len(w.entriesHeader) : footerStart], nil
}

func (w *Writer) replaceContent(newHosts string) error {
	oldContent, err := w.getCurrentGeneratedHosts()
	if err != nil {
		return err
	}

	currentContent, err := w.getCurrentHostsContent()
	if err != nil {
		return err
	}
	newContent := strings.ReplaceAll(currentContent, oldContent, w.lineEndings+newHosts+w.lineEndings)

	_, err = w.hostsAdapter.Write([]byte(newContent))
	if err != nil {
		return errors.Wrap(err, "cannot write new hosts content")
	}

	return nil
}

func (w *Writer) isHeaderPresent(content string) bool {
	return strings.Contains(content, w.entriesHeader)
}

func (w *Writer) isFooterPresent(content string) bool {
	return strings.Contains(content, w.entriesFooter)
}
